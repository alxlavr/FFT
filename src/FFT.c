/*!
 * \file FFT.c
 *
 * \brief     Файл процедур вычисления дискретного преобразования Фурье над входным массивом данных.
 * \details   Реализован алгоритм быстрого преобразования Фурье с возможностью использования линейной
 *            оконной функции для входных данных и вычисления модуля полученного комплексного числа.
 *
 * \version   1.0
 * \date      11.10.2021 11:36:09
 * \authors   Лаврентьев Алексей Игоревич
 */

#include "FFT.h"

int16_t FFT_sin[] = {0, -16384, -11585, -6270, -3196, -1606, -804, -402, -201, -100};
int16_t FFT_cos[] = {-16384, 0, 11585, 15137, 16069, 16305, 16364, 16379, 16383, 16384};

uint16_t FFT_len = 0;   ///< Длина массива преобразования кратная 2. Возможные значения 4, 8, 16, 32, 64, 128, 256, 512, 1024
uint16_t FFT_m = 0;     ///< Показатель степени 2 значения длины массива входных данных
uint16_t FFT_freq = 0;  ///< Частота дискретизации массива входных данных

/** функция возвращает номер установленного бита  0b00010000 => 4 **/
uint8_t _data_bit_num(uint8_t byte);
uint32_t _my_sqrt(uint32_t x);
uint32_t _abs(int32_t x);

/*!
 * \brief            Функция инициализации преобразования.
 * \details          Функция определяет длину массива входных данных и частоту дискретизации.
 * \param fft_len    Длина массива входных данных отсчетов.
 * \param freq       Частота дискретизаии отсчетов.
 */
void FFT_init(uint16_t fft_len, uint16_t freq)
{
    FFT_freq = freq;
	FFT_len = fft_len;
	if(fft_len > 255)
	{
        FFT_m = 8 + _data_bit_num(FFT_len >> 8);
	}
	else
    {
        FFT_m = _data_bit_num(FFT_len);
	}
}

/*!
 * \brief            Функция подготовки окна данных во времени взвешивающей функцией (линейная).
 * \details          Функция осуществляет подготовку дискретных отсчетов перед вычислением преобразования.
 *                   Такая подготовка важна для устранения влияния конечности данных для преобразования.
 * \param *REX       Ссылка на массив вещественной части отсчетов входных данных.
 * \param *IMX       Ссылка на массив мнимой части отсчетов входных данных.
 * \param line_len   Длина "крыльев" окна линейной взвешивающей функции.
 * \return           Функция возвращает значения вещественной и мнимой частей входных данных
 *                   во входных массивах *REX и *IMX взвешенных по времени.
 */
void FFT_window_Line(int16_t *REX, int16_t *IMX, uint16_t line_len)
{
	if(line_len > FFT_len / 2) return;
	for(uint16_t i = 0; i < line_len; i++)
	{
		REX[i] = (REX[i] * i) / line_len;
		REX[FFT_len - i] = (REX[FFT_len - i] * i) / line_len;
		IMX[i] = (IMX[i] * i) / line_len;
		IMX[FFT_len - i] = (IMX[FFT_len - i] * i) / line_len;
	}
}

/*!
 * \brief            Функция быстрого преобразования Фурье.
 * \details          Функция осуществляет вычисление преобразования Фурье.
 * \param *REX       Ссылка на массив вещественной части отсчетов входных данных.
 * \param *IMX       Ссылка на массив мнимой части отсчетов входных данных.
 * \return           Функция возвращает значения вычисленной вещественной и мнимой частей данных
 *                   во входных массивах *REX и *IMX.
 */
void FFT_math(int16_t *REX, int16_t *IMX)
{
	int32_t Tr = 0;
	int32_t Ti = 0;
	uint16_t Nm1 = FFT_len - 1;
	uint16_t Nd2 = FFT_len >> 1;
	uint16_t Le = 0;
	uint16_t Le2 = 0;
	uint16_t Jm1 = 0;
	int32_t Ur = 0;
	int32_t Ui = 0;
	uint16_t Ip = 0;
	int32_t Si = 0;
	int32_t Sr = 0;
    uint16_t j = Nd2;
	uint16_t k = Nd2;

    // перестановка массива во временной области
	// бит-реверсивная сортировка

    for(uint16_t i = 1; i < FFT_len - 1; i++)
	{
		if(i < j)
		{
			Tr = REX[j];
			Ti = IMX[j];
			REX[j] = REX[i];
			IMX[j] = IMX[i];
			REX[i] = Tr;
			IMX[i] = Ti;
		}
		k = Nd2;
		while(k <= j)
		{
			j = j - k;
			k = k >> 1;
		}
		j = j + k;
	}

	// цикл по ступеням преобразования 
	for(uint16_t L = 1; L <= FFT_m; L++)
	{
		Le = 1 << L;
		Le2 = Le >> 1;
		Ur = 16384;            // задаем начальную омега 
		Ui = 0;
		Sr = FFT_cos[L - 1];   // шаг угла преобразования 
		Si = FFT_sin[L - 1];   // определяется ступенью преобразования 

		// цикл внутри ступеней преобразования
		for(uint16_t J = 1; J <= Le2; J++)
		{
		    Jm1 = J - 1;
			// цикл по отдельным "бабочкам"
			for (uint16_t i = Jm1; i <= Nm1; i += Le)
			{
				Ip = i + Le2;
				Tr = (REX[Ip] * Ur - IMX[Ip] * Ui) >> 14;  // перемножение омега комплексных чисел реальная часть
				Ti = (REX[Ip] * Ui + IMX[Ip] * Ur) >> 14;  // перемножение омега комплексных чисел мнимая часть
				REX[Ip] = REX[i] - Tr;                     // концы "крыльев бабочки" 
				IMX[Ip] = IMX[i] - Ti;                     // концы "крыльев бабочки"
				REX[i] = REX[i] + Tr;                      // концы "крыльев бабочки"
				IMX[i] = IMX[i] + Ti;                      // концы "крыльев бабочки"
			}

			Tr = Ur;
			Ur = (Tr * Sr - Ui * Si) >> 14;                // находим омега в квадрате действительная часть
			Ui = (Tr * Si + Ui * Sr) >> 14;                // находим омега в квадрате мнимая часть
		}
	}
}

/*!
 * \brief            Функция вычисления модуля комплексного числа выходных данных.
 * \details          Функция обеспечивает вычисления длины полученного вектора числа.
 * \param *REX       Ссылка на массив вещественной части отсчетов данных.
 * \param *IMX       Ссылка на массив мнимой части отсчетов данных.
 * \param *MODX      Ссылка на массив для записи результата вычисления модуля комплексного числа.
 * \return           Функция возвращает значения модуля комплексного числа в массиве *MODX.
 */
void FFT_mod(int16_t *REX, int16_t *IMX, uint16_t *MODX)
{
	for(uint16_t i = 0; i < FFT_len; i++)
	{
		MODX[i] = (uint16_t)_my_sqrt((int32_t)REX[i] * (int32_t)REX[i] + (int32_t)IMX[i] * (int32_t)IMX[i])/FFT_len;
	}
}

/*!
 * \brief            Функция вычисления квадратного корня.
 * \param x          Входное число.
 * \return           Функция возвращает значениякорня квадратного от входного числа.
 */
uint32_t _my_sqrt(uint32_t x)
{
	uint32_t S = x;
	uint32_t a = 1;
	uint32_t b = x;

	while(_abs(a - b) > 1)
	{
		a = (a + b) >> 1;
		b = S / a;
	}
	return (a + b) >> 1;
}

/*!
 * \brief            Функция вычисления квадратного корня.
 * \param x          Входное число.
 * \return           Функция возвращает значение корня квадратного от числа x.
 */
uint32_t _abs(int32_t x) {
    if(x < 0) return -x;
    return x;
}

/*!
 * \brief            Функция вычисляет текущую частоту отсчета в выходных данных.
 * \param i          Номер отсчета в выходных данных преобразования.
 * \return           Функция возвращает текущую частоту отсчета.
 */
uint16_t FFT_current_frequency(uint16_t i)
{
    return i*(FFT_freq / (FFT_len >> 1));
}

/*!
 * \brief            Функция вычисления показателя степени числа 2 из байта.
 * \param byte       Входной байт кратный степени 2.
 * \return           Функция возвращает номер установленного бита, например 0b00010000 => 4.
 */
uint8_t _data_bit_num(uint8_t byte)
{
	for(uint8_t i = 0; i < 8; i++)
	{
		byte = byte >> 1;
		if(byte == 0) return i;
	}
	return 0;
}
